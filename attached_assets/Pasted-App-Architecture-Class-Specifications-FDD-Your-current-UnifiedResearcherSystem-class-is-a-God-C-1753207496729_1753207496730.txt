App Architecture & Class Specifications (FDD)
Your current UnifiedResearcherSystem class is a "God Class" that does everything. For a robust Streamlit app, we must break this down into smaller classes, each with a single responsibility. This aligns with FDD's focus on modeling the domain.

Overall Domain Object Model
The system will be composed of several key domain objects (classes) that the main app.py will orchestrate.

app.py (UI Controller) → DataLoader (Loads data) → ResearcherMatcher (Finds matches) → TeamBuilder (Assembles team) → ReportGenerator (Creates final output)

Class Specifications
1. data_models.py

Domain: This file won't contain logic, but it's crucial for defining the shape of your data. It should hold all the @dataclass definitions (ResearcherMatch, MatchingResults, DreamTeamReport). Centralizing these makes your code cleaner and easier to type-hint.

2. data_loader.py → DataLoader Class

Domain: Responsible for loading and caching all necessary data files and models from your persistent Replit storage. This prevents the app from reloading large files on every user interaction.

Key Methods & Logic:

__init__(self, data_dir): Takes the path to the data directory.

@st.cache_resource
def load_models(_self): Loads the tfidf_model.pkl and the SentenceTransformer. The _self argument is a convention for using Streamlit caching within a class.

@st.cache_data
def load_data_files(_self): Loads the researcher vectors, conceptual profiles, evidence index, and metadata Parquet file.

get_all_data(self): A helper method that calls the two loading methods and returns all the necessary data objects in a structured way (e.g., a dictionary).

3. matcher.py → ResearcherMatcher Class

Domain: Encapsulates all logic related to scoring and ranking individual researchers against a solicitation.

Key Methods & Logic:

__init__(self, models, data): Takes the pre-loaded models and data from DataLoader.

score_researcher(self, researcher_id, skills, solicitation_embedding): The exact logic from your original score_researcher function. It calculates sparse, dense, and final scores for one person.

search_researchers(self, solicitation_obj): The main entry point. It orchestrates the filtering and scoring of all eligible researchers, returning a MatchingResults object. It should not contain any data loading code.

4. team_builder.py → TeamBuilder Class

Domain: Contains all algorithms and logic for assembling the optimal team from a list of top candidates.

Key Methods & Logic:

__init__(self, models, data): Takes pre-loaded models and data, specifically the TF-IDF model and researcher vectors needed for the affinity matrix.

create_affinity_matrix(self, matching_results): Generates the researcher-skill affinity matrix.

dream_team_hybrid_strategy(self, affinity_df): Implements the primary team selection algorithm.

calculate_team_coverage(...) & calculate_marginal_gain(...): Helper methods for the team-building logic.

assemble_team(self, matching_results): The main public method. It takes the results from the ResearcherMatcher, creates the affinity matrix, runs the hybrid strategy, and returns the selected team indices and selection history.

5. report_generator.py → ReportGenerator Class

Domain: Responsible for generating all human-readable outputs, including the AI analysis and the final Markdown report.

Key Methods & Logic:

__init__(self, groq_api_key): Initializes the Groq client.

generate_strategic_analysis(self, coverage_report, solicitation_data): Calls the Groq API to get the AI-powered analysis.

get_team_evidence(...): Extracts the supporting paper evidence for the final team.

format_markdown_report(self, dream_team_report, team_evidence): Formats the complete Markdown string for display and download.

generate_full_report(self, affinity_df, team_indices, selection_history, ...): The main method that orchestrates the creation of the final DreamTeamReport object by calling the other methods in the class.

Project Structure
Organize your files in Replit for clarity and maintainability.

/
├── data/                    # Persistent data files
│   ├── researcher_vectors.npz
│   ├── tfidf_model.pkl
│   ├── researcher_metadata.parquet
│   └── ...
├── modules/                 # Your refactored Python code
│   ├── data_loader.py
│   ├── data_models.py
│   ├── matcher.py
│   ├── team_builder.py
│   └── report_generator.py
├── .streamlit/
│   └── secrets.toml         # For storing the GROQ_API_KEY
├── app.py                   # Main Streamlit application file
└── requirements.txt         # All Python package dependencies
FDD Task Breakdown
Here is the feature list, broken down into actionable tasks.

Feature 1: System Initialization & Configuration

Task 1.1: Develop the DataLoader class to load and cache all models and data files using @st.cache_resource and @st.cache_data.

Task 1.2: In app.py, create the sidebar UI for Groq API key input and solicitation file selection.

Task 1.3: In app.py, instantiate DataLoader and call it to load all data into a single, cached data object.

Task 1.4: Use Replit's secrets management for the GROQ_API_KEY.

Feature 2: Researcher Matching & Ranking

Task 2.1: Refactor scoring logic into the ResearcherMatcher class.

Task 2.2: In app.py, add the "Analyze Solicitation" button. When clicked, it should:

Instantiate ResearcherMatcher.

Call matcher.search_researchers().

Store the returned MatchingResults object in Streamlit's st.session_state.

Task 2.3: Develop a UI function in app.py to display the top_matches from the session state in a clean st.dataframe.

Feature 3: Dream Team Assembly

Task 3.1: Refactor all team-building algorithms into the TeamBuilder class.

Task 3.2: In app.py, add a "Build Dream Team" button that only appears after matching is complete. When clicked, it should:

Instantiate TeamBuilder.

Call team_builder.assemble_team(), passing the matching results from st.session_state.

Store the resulting affinity matrix, team indices, and selection history in st.session_state.

Task 3.3: Develop a UI function to display the assembled team members and their roles.

Feature 4: Strategic Report Generation

Task 4.1: Refactor reporting and Groq logic into the ReportGenerator class.

Task 4.2: After the team is assembled, app.py should automatically:

Instantiate ReportGenerator.

Call report_generator.generate_full_report() to get the final DreamTeamReport object and evidence.

Store these final results in st.session_state.

Task 4.3: Develop a UI function to display the final report using st.markdown, including the skill coverage table and the AI analysis.

Task 4.4: Add an st.download_button to allow the user to save the formatted Markdown report to a file.